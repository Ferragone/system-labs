**Рефакторинг для покращення архітектури коду: інноваційні рішення**

У наведеному прикладі коду використовувався довгий ланцюжок викликів `bank.get_customer().get_account().get_balance()`. Це створювало тісні залежності між класами та ускладнювало підтримку і розширення коду.

### Прийняті рішення:

**Інкапсуляція ланцюжка викликів:**
Для інкапсуляції довгого ланцюжка викликів був доданий метод `get_balance` до класу `Bank`. Цей метод інкапсулює ланцюжок викликів і надає доступ до балансу безпосередньо, приховуючи деталі реалізації від зовнішніх класів. Тепер, щоб отримати баланс, достатньо викликати метод `get_balance` у класі `Bank`, що значно спрощує код і робить його більш інтуїтивно зрозумілим.

```python
class Bank:
    def get_balance(self, customer_id):
        customer = self.get_customer(customer_id)
        account = customer.get_account()
        return account.get_balance()
```

**Спрощення інтерфейсу:**
Метод `get_balance` забезпечує простий та зрозумілий інтерфейс для отримання балансу. Замість довгого ланцюжка викликів тепер можна використовувати один метод, що зменшує кількість коду і підвищує його читабельність. Це також полегшує використання класу `Bank` іншими розробниками, оскільки їм більше не потрібно знати про внутрішню структуру класів `Customer` та `Account`.

**Зменшення залежностей:**
Тепер класи `Customer` та `Account` не мають публічних методів для отримання внутрішніх даних, що сприяє зниженню залежностей між класами. Це означає, що зміни у внутрішній реалізації цих класів не вплинуть на зовнішні класи, що робить систему більш стабільною і легшою для підтримки.

### Переваги такого підходу:

1. **Поліпшення модульності:**
   Інкапсуляція ланцюжка викликів робить систему більш модульною. Кожен клас тепер відповідає за свою частину логіки, що полегшує тестування і обслуговування коду.

2. **Підвищення читабельності:**
   Спрощений інтерфейс робить код більш зрозумілим і легким для читання. Розробники можуть швидко зрозуміти, як отримати необхідну інформацію, не заглиблюючись у деталі реалізації.

3. **Зниження ризику помилок:**
   Зменшення залежностей між класами знижує ризик виникнення помилок під час внесення змін. Кожен клас тепер ізольований від змін в інших класах, що робить систему більш надійною.

4. **Спрощення розширення функціональності:**
   Додавання нових функцій тепер відбувається простіше, оскільки внутрішні зміни не впливають на інтерфейси інших класів. Це робить систему більш гнучкою і легкою для розширення в майбутньому.

Цей рефакторинг значно покращує архітектуру системи, робить її більш гнучкою, модульною та легшою для підтримки і розширення в майбутньому.